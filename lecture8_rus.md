# Настраиваем Gradle для генерации Java кода с помощью protobuf
На последней лекции мы закончили на том, что создали сообщения protocol buffer
и генерировали Go код для них. Теперь мы сделаем то же самое для Java. Сначала
мы установим Java Development Kit и Intellij IDEA. Затем мы создадим новый
Gradle проект, настроим несколько плагинов и сконфигурируем их для 
автоматической генерации Java кода. Мы также узнаем как использовать 
определенную опцию для кастомизации сгенерированных кодов.

## Устанавливаем JDK
Итак, давайте начнём! Сначала откройте терминал и выполните команду `javac`, 
чтобы проверить, доступна ли среда выполнения для Java. Если нет, то вам будет 
предложено установить JDK или Java Development Kit. Нам понадобится как минимум
Java версии 8, чтобы использовать все возможности gRPC. Поэтому нажмите на 
кнопку "More info...", чтобы открылся веб-сайт Java Oracle. Последней версией 
JDK является 13, что более, чем достаточно для нас. Мы должны принять 
лицензионное соглашение, а затем выбрать правильный пакет для нашей ОС. Я 
использую macOS, поэтому загружу файл jdk-13.0.1_osx-x64_bin.dmg. После 
завершения загрузки, откройте файл, чтобы начать установку. Как только 
установка завершиться, запустите `javac`, чтобы проверить его 
работоспособность.

```shell
javac -version
```

## Устанавливаем Intellij IDEA
Отлично! Следующий шаг — установка Intellij IDEA. Введите `Intellij IDEA java` 
в поисковой строке вашего браузера. Откройте веб-сайт `jetbrains.com` и нажмите
`Download`. Мы будем использовать бесплатную версию. Установка в macOS 
происходит очень просто. Откройте dmg файл и перетащите `IntelliJ IDEA` в папку
`Applications`. Когда мы откроем приложение, macOS запросит подтверждение, 
поскольку это приложение было загружено из интернета, а не из магазина 
приложений. Нажмите кнопку `Open`. Не нужно импортировать настройки. Мы должны
принять условия политики конфиденциальности Jetbrains. Нажмите `Continue` и на 
этом установка будет завершена.

## Настраиваем Gradle проект и плагины
Давайте создадим новый проект. Мы будем использовать `Gradle`, потому что
Google поддерживает официальный grandle плагин для protobuf. Для SDK проекта 
убедитесь, что выбрана правильная версия Java. Затем нажмите на кнопку `Next`.
Заполните `GroupID`. Я введу `com.gitlab.techschool`. В поле `ArtifactID` 
пропишите `pcbook`. Проверьте, что название проекта и его путь указаны 
правильно и затем нажмите `Finish`. Настройка проекта в IntelliJ IDEA может 
занять несколько секунд. Когда настройка будет завершена, откройте 
`build.grandle` файл для настройки некоторых плагинов. Сначала настроим плагины
`protobuf-grandle` от Google. Откройте браузер и введите в поисковике 
`protobuf java grandle`. Одной из первых будет ссылка на страницу [github.com](https://github.com/google/protobuf-gradle-plugin).
Прокрутите немного вниз, скопируйте блок `Using the Gradle plugin DSL` и 
вставьте его в наш `build.grandle` файл. Затем нам нужно добавить в наш проект
зависимость: `protobuf-java`. Поищем в браузере `maven protobuf java`. Поиск 
приведёт нас на страницу с репозиторием [maven](https://mvnrepository.com/artifact/com.google.protobuf/protobuf-java).
Мы находимся внутри `protobuf-java` артефакта пакета `com.google.protobuf`. 
На момент написания лекции последней выпущенной версией была 3.15.6, поэтому 
давайте выберем её. Нажмите на вкладку `Gradle` и скопируйте эту настройку

```
// https://mvnrepository.com/artifact/com.google.protobuf/protobuf-java
implementation group: 'com.google.protobuf', name: 'protobuf-java', version: '3.15.6'
```

затем вставьте её в блок зависимостей нашего `build.gradle`. Нам также 
понадобится пакет для работы с gRPC, поэтому вернемся на страницу репозитория
maven и поищем `grpc-all`. Выберите последнюю версию. Для меня — это 1.36.1. По
аналогии откройте `Gradle` вкладку и скопируйте настройку. Затем вставьте её 
в блок зависимостей. IntelliJ IDEA автоматически обнаружит и сконфигурирует 
её за нас. Теперь настроим компилятор protobuf. По умолчанию, 
`protobuf-gradle-plugin` будет искать исполняемый файл `protoc` в системе. Мы
уже установили его в предыдущей лекции с помощью Homebrew. Однако, если Вы не
устанавливали его, я покажу вам другой способ получить предварительно 
скомпилированный `protoc`. Сначала перейдите в репозиторий maven и найдите
`protoc`. Последняя версия - 3.15.6, но мы не добавим его в блок зависимостей
как делали раньше. Вместо этого мы настроим его в отдельном блоке. Вернемся на 
github страницу `protobuf-gradle-plugin` и скопируем блок `Locate external 
executables`. Вставим его в наш `build.gradle` файл. Замените версию на 
последнюю: 3.15.6 и IntelliJ сделает всё остальное за нас. Теперь нужно не 
забыть указать `protoc` использовать gRPC плагин при генерации Java кода. Для
этого мы можем вернуться на github страницу `protobuf-gradle-plugin` и 
поискать этот блок:

```
protobuf {
  ...
  // Locate the codegen plugins
  plugins {
    // Locate a plugin with name 'grpc'. This step is optional.
    // If you don't locate it, protoc will try to use "protoc-gen-grpc" from
    // system search path.
    grpc {
      artifact = 'io.grpc:protoc-gen-grpc-java:1.0.0-pre2'
      // or
      // path = 'tools/protoc-gen-grpc-java'
    }
    // Any other plugins
    ...
  }
  ...
}
```

Тут указан артефакт для `protoc-gen-grpc-java`. Давайте найдём его последнюю
версию в репозитории maven. На момент написания — это 1.36.1. Отлично, теперь 
скопируем этот блок и вставим его. Изменим версию на 1.36.1. Давайте немного 
почистим код, удалив из него комментарии. Затем мы должны добавить настройку
`generateProtoTasks`, чтобы `protoc` использовал наш `grpc` плагин.

```
protobuf {
    protoc {
        artifact = 'com.google.protobuf:protoc:3.15.6'
    }

    plugins {
        grpc {
            artifact = 'io.grpc:protoc-gen-grpc-java:1.36.1'
        }
    }

    generateProtoTasks {
        all()*.plugins {
            grpc {}
        }
    }
}
```

Я знаю, что всё это выглядит достаточно сложно и нужно настроить много всего. 
Однако, поверьте мне, это поможет нам значительно ускорить этап разработки. 
Осталось сделать ещё кое-что прежде, чем мы продолжим. Нужно указать IntelliJ 
IDEA где будет храниться наш сгенерированный код. Таким образом, в дальнейшем 
ИСР сможет легко и правильно выполнять анализ кода, осуществлять автодополнение
кода. Для этого будем использовать блок `sourceSets`. Внутри этого блока 
зададим два каталога: один для gRPC, а другой — для protobuf сообщений. Итак, 
теперь всё действительно готово к работе.

## Генерируем код из proto файлов
Давайте создадим новую папку `proto` внутри `src/main` (создайте папку 
`src/main`, если её не существует). Затем скопируйте все proto файлы, которые
были созданы на предыдущей лекции в эту папку. Файлы скопированы, но нет 
подсветки кода. IntelliJ IDEA выдаст сообщение о необходимости установки 
плагинов для этого, поэтому давайте нажмём `Install`. Нужно перезапустить 
IntelliJ IDEA, чтобы изменения вступили в силу. После того как файлы 
проиндексируются, подсветка должна появиться. Теперь самое интересное. Как 
только вы нажмёте на иконку `Build` IntelliJ IDEA запустит несколько фоновых 
задач для генерации кода. Как видно из логов создаётся довольно много задач. 
Когда эти задачи завершат своё выполнение, сгенерированный код будет находиться
в папке `build/generated/source/proto/main/java`. Папка `grpc` в настоящее 
время пуста, поскольку мы не написали пока ни одной RPC. В папке `java` 
находятся шесть java файлов, по одному на каждое сообщение. В файлах довольно 
много кода, а название сгенерированного пакета совпадает с названием protobuf
пакета: `techschool_pcbook`. Мы можем легко изменить это название, как мы уже
делали для Go, используя опцию `option java_package`. Я буду использовать
`com.github.techschool.pcbook.pb`. Мы также укажем `protoc`, что необходимо 
разбить код на несколько файлов небольшого размера вместо того, чтобы помещать 
всё в один большой файл. Это легко сделать, присвоив значение `true` опции 
`java_multiple_files`.

```protobuf
option java_package = "com.github.techschool.pcbook.pb";
option java_multiple_files = true;
```

Давайте скопируем и вставим эти новые параметры во все наши proto файлы. Теперь
я удалю старый сгенерированный код и повторно соберу проект. Отлично, всё 
настройки сработали: большие файлы разбились на несколько и изменилось название 
пакета на то, которое мы указали. Прежде, чем мы закончим, я скопирую всё наши
измененные файлы в Go проект, поскольку мы всегда хотим, чтобы наши proto файлы
во всех компонентах системы были синхронизированы.

На этом всё! Мы закончили! На следующей лекции, мы начнём писать код на Go и 
Java для сериализации protobuf сообщений. Благодарю за потраченное время и до 
новых встреч.